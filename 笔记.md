#  a target:属性

## _blank

浏览器总在一个新打开、未命名的窗口中打开载入目标文档

## _self

指在目标文档载入并显示在相同的框架或窗口中作为源文档（这个目标多余且不必要，除非和文档标题<base>标签中的target属性一块使用）

## _parent

使文档载入父窗口中

## _top

使文档载入最顶层窗口，即整个浏览器窗口

# img标签

## alt属性

当图片不存在/加载不成功时，出现的破损标识

## title属性

鼠标移到图片上提示的文字

# span标签

与div一样，都是用来布局的，不同的是div自带换行符，而span没有。span用于行内布局

# ul/ol标签

前者为无序列表、后者为有序列表，同用<li>标签

# 企业网站命名规范

![image-20201014181355057](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201014181355057.png)





# 自定义标签属性：

作用：通常用来值或用于图片懒加载等方面。

格式:data-*

<img data-src="图片路径"  alt="提示文本"/>

<p data-id="Goodsid">...</p>

# table表格

table主要用于呈现格式化数据。它是由行和列组成的。

格式：

<table>
    <tr>
    	<th></th>
        <td></td>
        ...
    </tr>
    ...
</table>

## table包含属性

border:边框大小

width:宽度

cellspacing:两个单元格之间的距离

cellpadding:单元格内边距（文本与边框距离）

align:table位置是居左居右还是居中,即对齐方式

## 表格跨行/跨列属性

rowspan:跨行

<table border="1" width="500" align=center>
    <tr>
        <td rowspan="2">内容区01</td>
        <td>内容区02</td>
        <td>内容区03</td>
    </tr>
	<tr>
        <td>内容区02</td>
        <td>内容区03</td>
    </tr>
    <tr>
        <td>内容区01</td>
        <td>内容区02</td>
        <td>内容区03</td>
    </tr>
</table>



colspan:跨列

<table border="1" width="500" align=center>
    <tr>
        <td>内容区01</td>
        <td colspan="2" align="center">内容区02</td>
    </tr>
	<tr>
        <td>内容区01</td>
        <td>内容区02</td>
        <td>内容区03</td>
    </tr>
    <tr>
        <td colspan="3" align="right">内容区01&nbsp;&nbsp;</td>
    </tr>
</table>





### valign类

#### 含义

规定它的垂直对齐方式，如：

top:顶端；

middle:中间;

bottom:底端;

整个垂直方式可以在tr标签上改变所有该标签内的td标签的垂直方式





# 完整表格组成格式

caption(标题)、thead(表头)、tbody(表体)和tfoot(表尾)四部分组成。

```html
<table border="1" width="600" align="center">
    <caption>学生信息表</caption>
    <thead>
    <tr>
        <th>学号</th>
        <th>姓名</th>
        <th>家庭住址</th>
        <th>备注</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>001</td>
        <td>张三*</td>
        <td>aaaaaa</td>
        <td>该生为“三好学生”</td>
    </tr>
    <tr>
        <td>002</td>
        <td>Mickle</td>
        <td>bbbbbb</td>
        <td></td>
    </tr>
    <tr>
        <td>003</td>
        <td>Mary*</td>
        <td>cccccc</td>
        <td></td>
    </tr>
    <tfoot>
    <tr>
        <td colspan="4">附注:*为优秀学生</td>
    </tr>
    </tfoot>
    </tbody>
</table>
```

# form表单标签

是所有标签中最核心的标签之一，它是用来实现前后端交互的一个重要标签。

## 常用属性

name:表单名称

action:表单数据提交的地方(通常是一个后台文件名(.jsp/.php/.asp/aspx/.py等)，或网址)。如果是#，表示提交到当前文件下。

method:前端提交数据到后台/后端的方法，主要有两个:get或者post,默认为get提交方法，post相对get更安全；

## 表单元素

表单元素分为：input类、textarea类、select类、button类

### 1)input

用法：主要用来输入，选择或发出指令

它的type类型有8种，

text：定义文本输入的单行输入文段，默认值。

属性:placeholder(提示)/name(命名)/minlength和maxlength(最少/多输入的字符个数)/disabled(失效)/readonly(只读)/value(默认值)/pattern(正则匹配)。

password：定义密码字段

属性与text一致。

image：定义图片提交按钮、用法与button基本一致。有一个特殊属性:src（用来加载提示图片，用它替换了value）

它也有提交功能，与submit功能一样。

radio：定义单选按钮，通常是两项以上

常用属性:name(必须要有)/value(值)/checked(定义是否选中)/disabled(失效)/readonly(只读)

checkedbox：定义复选框可以用来选择0项、1项或多项。

常用属性:name(必须要有)/value(值)/checked(默认选中)/disabled(失效)/readonly(只读)

button：定义普通按钮,通常用它去调用脚本代码。

常用属性:value(按钮的标题)/disabled(失效)

reset：定义重置按钮，将表单所有组件输入的内容全部清空，还原为初始状态

常用属性:value(按钮的标题)/disabled(失效)

submit：定义提交表单数据到表单处理程序的按钮，用来将表单数据提交到后台

常用属性:value(按钮的标题)/disabled(失效)

file：定义文件上传按钮

### 2)textarea

文本域（也可以叫多行文本框），主要用来输入大批量的内容。

常用属性：name/id/cols(列数)/rows(行数)/placeholder(提示)/minlength(最少字符)/maxlength(最大字符)/required(必须输入)/value

### 3)select

下拉列表框，默认用于单项选择。

如果添加multiple属性，表示可以多选,这时的下拉列表框变成了列表框

size：最多显示的行数

### 4)button

普通按钮，具有提交功能。可以单独使用，不卸载form元素中。如果写在form中，有提交功能。

## 表单的通用属性

有name、value、readonly、disabled。

name：规定输入字段的的名称。

value：规定输入字段的初始值。

readonly：规定输入字段为只读。

disabled：规定输入字段为禁用。

# iframe框架标签

定义：框架集，是用来将多个网页文件组合成一个文件。

常用属性：

src：规定在框架中显示的文档URL

name：规定框架的名称

width：iframe设置宽度

height：iframe设置高度

frameborder：设置框架边框(是否有边框[1/0])

scrolling：设置滚动条(yes/no/auto)

marginheight：框架离顶部和底部的距离（%/px）

marginwidth：框架离左右的距离（%/px）

注意：

在实际开发中，尽量减少使用iframe，应为他破坏了前进和后退功能，且不利于SEO（搜索引擎）,即不利于我们抓取关键字

# CSS

定义：层叠样式表，用来美化网页的，做到结构(HTML)和表现（CSS）分离，方便维护

## 基本语法

选择器{

​	属性：属性值；

}

## css引用方式

行间样式：直接在标签上书写样式。

<div style=""></div>


内部样式：在文件的内部书写样式

<style type="text/css">
    p{

```html
}
</style>
```

外部样式：（1）先创建css文件；（2）在用link标签引入这个标签

<link href="链接" rel="stylesheet" type="text/css">



导入外部样式：（1）先创建css文件；（2）在style标签中用import导入这个样式文件。

text.css文件中

.box{

background-color:#000000;

}

html文件中

<style type="text/css">
    @import "text.css"
</style>

## 四种CSS引用的区别

行间样式只作用于当前标签；而内部样式作用于当前文件；外部样式可以被多个HTML文件使用。在实际项目开发中。最好且最多使用外部样式。

外部样式分为link引入和import引入两种方式，这两种方式的区别在于：

1、link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。

2、link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。

3、link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。

4、link支持使用javascript控制DOM去改变样式；而@import不支持。

## CSS选择器分类

1）*:匹配html中所有元素（注意：*的性能非常差，因为它要匹配所有元素，所以在开发时，不建议使用）

2）标签选择器：用来匹配对应的标签

3）类选择器：用来选择class命名的标签

4）ID选择器：用来选择用id命名的标签

5）派出选择器：根据上下文来确定要选择的标签

6）伪类选择器（后面学）

## 选择器的分组

让多个选择器（元素）具有相同的样式，一般用于设置公共样式

## 选择器的继承

子元素可以继承父元素的样式，反之不可以。

## 优先级

多重样式：如果外部样式、内部样式和内联样式同时应用于同一元素，就是使多重样式的情况。一般情况下，优先级如下：（外部样式）<（内部样式）<（内联样式）

## 样式权重

!important(10000)>内联样式（1000）>id选择器（100）>类、伪类选择器（10）>标签选择器（1）

## css字体

1)font-size:字号

属性值

px/%;

2)font-family:字体

属性值 

name:字体名称，按优先顺序排列，以逗号隔开。如果字体名称包含空格，则应由引号括起；若不支持该字体，在字体后添加其他字体，浏览器将会使用后面的字体，以此类推，都不支持浏览器会提供一种默认字体体现。

3)font-style:字的样式

属性值 

normal：默认字体；

italic：斜体，对于没有倾斜变量的特殊字体将应用oblique；

oblique：倾斜的字体；

4)font-weight:加粗方式

属性值

normal:默认字体；

bold:粗体；

bolder:比bold粗；

lighter:比normal细；

(100-900):定义由粗到细的字符。400等同于normal，而700等同于bold。

5)line-height:行高

属性值

normal：默认行高

{number+px}:指定行高为长度像素

{number}:指定行高为字体大小的倍数

6)color:字体颜色

属性值

name:颜色名称指定color

rgb:指定颜色为RGB值（0-255）

(颜色16进制):指定颜色为16进制；

7)text-decoration:文字修饰（下划线等）

属性值

normal:默认，无修饰

underline:下划线

line-through:贯穿线

overline:上划线

8)text-align:字体对齐方式

属性值

left:默认值，左对齐

center:居中

right:右对齐

9)text-transform:字体大小写

属性值

none:默认值

capitalize:将每个单词的第一个字母转换为大写。

uppercase:转换为大写。

lowercase:转换为小写。

10)text-indent:文本缩进

属性值

{number+px}:首行缩进number像素

{number+em}:首行缩进number字符

TIp：

font符合属性：

font:font-style font-variant font-weight font-size/line-height font-family;

1)注意属性值的位置顺序

2)除了font-size和font-family之外，其他仍和一个属性值都可以省略

3）font-variant:文本修饰 属性normal/small-caps（让大写字母变小一些）

## CSS背景 

1)background-color:背景色（transparent/color）

2)background-image:背景图（none/url({url}))

3)background-repeat:背景图片铺排方式（repeat/no-repeat/repeat-x/repeat-y）

4)background-position:设置对象的背景图像位置（{x-number|top|center|bottom}|{y-number|left|center|right}）

5)background-attachment:设置对象的背景图像滚动位置

(scroll[滚动]/fixed[固定])

6)background:简写属性：在一个声明中设置所有背景属性

(background:color image repeat attachment position)

## CSS伪类选择器

伪类：专门用来表示元素的一种特殊状态。

常用的伪类选择器：

a标签的伪类：

:link未被访问状态

:visited被访问状态

:hover鼠标悬停在上状态

:active鼠标点击状态

2):focus 获得焦点

3):first-child第一个元素

:last-child最后一个元素

:nth-child(number)第number个元素

## 属性选择器

[属性名]:包含有指定属性名的元素（常用）
[属性名=值]:属性名的值为指定值的元素（常用）

[属性名~=值] 属性名的值包含指定值的元素 

[属性名^=值] 属性名的值以指定值开头的元素 

[属性名$=值] 属性名的值以指定值结尾的元素 

## 关系选择器

空格：后代选择器

大于号：只选择儿子元素

+：兄弟选择

## css伪元素

CSS伪元素与伪类区别：

css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分。

伪类用于当已有元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。

它只有处于dom树无法描述的状态下才能为元素添加样式，所以将其称为伪类。

伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式，虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。

伪元素&伪类的特点：

伪元素和伪类都不会出现在源文档或者文档树中

伪类允许出现在选择器的任何位置，而一个伪元素只能跟在选择器的最后一个简单选择器后面

伪元素名和伪类名都是大小写不敏感的

有些伪类是互斥的，而其它的可以同时用在一个元素上。（在规则冲突的情况下，常规层叠顺序决定结果）。

:before/:after/:first-letter/:first-line:前面可以是一个冒号也可以是双冒号（常用）

::selection/::placeholder/;;backdrop:前面只能是双冒号

## css浮动

float属性定义元素在哪个方向浮动。以往这个属性总用于图像，使文本围绕在图像周围，不过在CSS中，任何元素都可以浮动，浮动的元素会生成一个块级框，而不论它本身是何种元素。如果浮动并非替换元素，则要制定一个明确的宽度；否则，他们会尽可能的窄。

可能的值：float的值

left:向左浮动

right:向右浮动

none:不浮动，默认值，会显示在其在文本中出现的位置

inherit:规定应从父类中继承float属性的值

浮动的原理：就是让元素脱离文档流，不占用标准流

浮动后，后面的元素不管是块级还是行级元素，不会显示在下一行。

### 清除浮动

目的：让后面的元素自动掉到下一行。

方法：

1)添加空标签，并设置样式：clear:both;

clear:left;	清除左浮动

clear:right;	清除右浮动

clear:both;	清除左右浮动

clear:none;	不清除左右浮动

2)在要清除浮动的父级添加样式：overflow:hidden;

overflow:hidden; //超出部分隐藏，也可以用来实现清除浮动

overflow属性

当子元素的尺寸超过父元素的尺寸时，需要设置父元素显示溢出的子元素方式，可在浮动元素的腹肌添加样式overflow:hidden;

<!--<div class='parents' style='overflow:hidden;'><div>-->

属性值:

visible:默认值。内容不会被裁剪，会呈现在元素框之外，不剪切也不添加滚动条。

auto:不显示超出部分内容，不剪切，会按照内容是否超出，自行添加，可用于清除浮动。

hidden:内容会被裁剪，且其余内容不可见，此属性还有清除浮动，清除margin-top塌陷的功能

scrooll:内容会被裁剪，但浏览器会显示滚动条以便查看其余内容。

3）使用:after（在要清除浮动的父级添加伪元素，并设定样式）

为了减少空标签的空余，可采用给父级的伪元素进行样式清除浮动。

样式：

父元素:after{

content:"";

display:block;

clear:both;

}

注意：在实际项目开发中，我们一般首先第二种方案。

## CSS盒子模型

每个元素都是一个盒子，一个盒子由margin,border,paddding,content组成。

## display属性

用来设置元素的显示方式

属性值：

none:不显示元素

block：块显示，在元素前后设置换行符，目的：将行级标签转换为块级标签（因为行级标签不识别宽高，而块级标签识别，转换后，行级标签也可设置宽高了）

inline：行内显示，将块级转换为行级标签

inline-block：将块级或行级标签转换为行内块级标签

## table属性

table一般不用来布局，主要用来格式化数据。

属性：

width：宽度

height：高度

border-collapse：单线边框

border：边框线

td，tr属性

width：宽度

height：高度

border：边框线

text-align:文本左右对齐（left/center/right）

vertical-align:文本上下对齐（top/middle[默认值]/bottom）

## 列表

不是描述性的文本任何内容都可以认为是列表。比如：菜单、商品列表等。

1）列表类型

无序(ul)、有序(ol)和自定义列表(dl)。

ul和ol的列表项都是用li表示的，而dl是由一个dt和一个或多个dd组成的

dl一般用来设定一个定义，比如名词解释等。dt：标题，dd：描述 ，用来对dt的内容进行解释说明的。

2）样式（用来修改标识类型）

list-style-image：用图像表示标识

list-style-position:标识的位置

list-style-type:标识类型

简写:

list-style:list-style-image list-style-position list-style-type

list-style的值可以按任意顺序列出，而且可以任意省略，只要提供一个值，其他的都自动默认



list-style-type的属性值：

a）无序

disc/circle/square

b）有序

decimal/decimal-leading-zero/lower-roman/upper-roman/lower-alpha/upper-alpha/lower-greek/lower-latin/upper-latin

有序和无序：

none

## 轮播图

作用：主要用于产品的展示或公司的相关宣传。

组成：

1)轮播组图（至少两张以上，不能太多）

2)控制器

3)计数器

## CSS定位布局

### 定位（position）

设定元素在文档中的位置。会将标签（元素）转换为块级。

#### 定位分类（属性值）

1)static：静态定位

默认值，没有定位，不能设置偏移值（left/top/right/bottom）,占用标准流（文档流）

2)relative：相对定位

占用标准流（文档流）他会出现在文档流中他该出现的位置，可以通过偏移值改变他的位置，他相对于自身所占的位置做了偏移。

3)absolute：绝对定位

脱离文档流，相对于body做了偏移。

绝对定位一般与相对定位结合使用。它相对的父级是relative定义的元素。relative的元素必须是absolute的父级。

在项目开发中，一般用relative+absolute结合使用。

4)fixed：固定定位

脱离当刘，相对于浏览器窗口左上角（0，0）做偏移，他与relative设定的对象没有关系，也就是说，他跟父级的定位没有任何关系，一般在开发中用来固定导航栏。

#### z-index

当多个元素添加了绝对定位，元素将会叠加在一起，使用z-index可以设置元素显示的层次。

注意：z-index只能在定位元素上奏效（例如：position：absolute）【其它例如：static和relative将无效】!

注意：元素可拥有负值的z-index属性值。

说明：一般元素为普通流，普通流的z-index默认为0，脱离了普通流，在普通流之上（定位，浮动）z-index为0-1之间。如果将z-index值设置为大于或等于1，元素将会在定位或者浮动流之上。

#### 网站开发策略

先整体，再局部，至顶向下，逐步细化。

1）双飞翼布局：由三列组成，两端固定，中间自适应。

优点：A.兼容性好，可以兼容所以的主流浏览器，包括万恶的IE6。

B.因为在DOM中center_panel在三列结构的最前面，因此可以实现主要内容的优先加载。

2）圣杯布局：由三列组成，两端固定，中间自适应。外观与双飞翼布局一致。

布局时与双飞翼比增加了定位和偏移设置

3）侧边栏固定布局

I）两栏布局

​	a）左侧固定，右侧自适应

​	b）左侧自适应，右侧固定

​	c）左右都固定

II)三栏布局

​	a）左侧固定，右侧固定，中间自适应

​	b）左侧自适应，中间和右侧固定

​	c）左侧和中间固定，右侧自适应

## BFC&IFC

FC(Fomatting Context[格式上下文])。他是CSS2.1规范终端一个概念。他是页面中的一块渲染区域，并有一套渲染规则，他决定了其子元素将如何定位，以及和其他元素的关系和相互作用。

分为BFC和IFC

### 1）BFC

块级格式上下文

#### a)形成BFC的条件

i)浮动元素(float除none以外的值)

ii)定位元素(position(absolute/fixed))

iii)display(inline-block/table-cell/table-caption时)

iv)overflow(值为hidden/auto/scroll时)

#### b)BFC特性

i)内部的盒子会在垂直方向上一个接一个的放置

ii)垂直方向上的距离会叠加，由最大margin值决定（如果不要叠加，就需要将该盒子变成一个独立的盒子）

iii)BFC的区域不会float元素区域重叠

iv)计算BFC的高度时，浮动元素也参与计算

v)BFC就是页面上的一个独立的容器，容器里面的子元素不会影响到外面的元素

#### c)BFC的作用

i)解决margin重叠的问题（添加独立BFC）

ii)解决浮动高度塌陷的问题（在父级添加overflow：hidden）

iii)解决侵占浮动元素的问题（添加overflow：hidden清除浮动）

### 2)IFC

内联（行级）格式上下文

#### a)行成IFC的条件

i)font-size

ii)line-height

iii)height

iv)vertical-align

#### b)IFC特性(规则)

i)IFC的元素会在一行中从左到右排列

ii)在一行上的所有元素会在该区域形成一个行框

iii)行宽的高度为包含后的高度、高度为行框中最高元素的高度

Iv)浮动的元素不会在行框中，并且浮动元素会压缩行框的宽度

v)行框的宽度容纳不下子元素时，子元素会换下一行显示，并且会产生新行框

vi)行框的元素内遵循text-align和vertical-align

## 容器的高度

height= line-height+vertical-align

……

（中间一部分内容缺失）



# CSS3(字体前缺失)

## web字体

开发者引入外部字体

语法

```
@font-face{
    font-family: caner;
    src: url("font/仓耳舒圆体.ttf") format("truetype")，url（“字体文件.woff”）format(...);
}
```

说明：可以同时引入多个字体文件，字体一样，文件的扩展名不一样，目的是为了处理浏览器兼容。



eg:

@font-face{

font-family:"iconfont";

src:url('iconfont.eot?t=1585647107785');/*IE9*/

src:url('iconfont.eot?t=1585647107785#iefix') format('embeded-opentype'),/*IE6-IE8*/

url('data:application')/x-font-wof2;charset=utf-8;base64,do9GMgBAAAAAAScAAsAAAACTAAAAROAAEAAAAAAAAAAAAA

url('iconfont.woff?t='1585647107785') format('woff'),

url('iconfont.ttf?t='1585647107785') format('truetype'),

url('iconfont.svg?t='1585647107785#iconfont') format('svg');

}



## icon-font图标字体

由阿里巴巴提供的一种图标字体

步骤：

1)进入官网 http://iconfont.cn,注册并登陆

2)创建一个项目

3)添加图标到购物车

4)将购物车中的图标添加到项目中

5)下载iconfont文件，解压后，将部分文件复制到网页项目中

6)使用字体图标前，先引入iconfont.css文件

7)使用图标方法：

a）用类名

《div class="iconfont icongerenzhongxin"></div》

b）使用unicode值

《div class="iconfont">&#xe62e;</div》

# javascript

js是运行在客户端的一种解释型编程语言。

## js的作用

用来完成前后端交互、增加用户体验的一些逻辑实现。

## 一个网页是由三部分组成的

结构（HTML/HTML5）、表现（CSS/CSS3）和行为（JavaScript）。

## 前端开发的核心

JavaScript

## JavaScript的组成

1）ECMAScript（标准：ECMA-262）：基础语言部分（基础、面向对象等）

2）DOM（标准：W3C）：节点操作

3）BOM（无标准）：浏览器操作

## JS的特点

### 1）松散性

JS的中变量没有一个明确的类型，也叫弱类型语言（允许将一块内存看作多种类型）。

### 2）对象属性

对象的属性也可以映射为任意的数据。

### 3）继承机制

JS是基于原型继承的。

## 使用Javascript

### 1）使用script标签（只能被当前HTML文件使用）

```
<script type="text/javascript" defer="defer" charset="utf-8">
  alert("这是我的第一个js程序");/*alert表示弹出一个警告框*/
</script>
```

defer:表示所有DOM元素加载完成后，再执行js代码（现在开发一般不需要）

charset：字体编码（主要解决汉字乱码问题）（现在开发一般不需要）

注意：

a、script标签可以写在网页代码的任意地方，因为js是同步执行的，但为了避免js阻塞和影响操作BOM，最好写在body后面。

b、如果要输出script结束标签时，必须拆开写：

```
alert('</sc'+'ript>');
```

### 2）在a标签的href中写js代码（实际开发中不建议这样使用，因为会影响到性能）

```
<a href="javascript:alert('大家好')">大家好</a>
<a href="javascript:var a=10,b=20;alert('结果为'+(a+b))">a+b=?</a>
<a href="javascript:close();">&times;</a>
<a href="javascript:void(1);">test</a>
```

### 3）用script标签引入外部js文件（可以被多个HTML文件使用）

```
<script src="javascript/test.js" type="text/javascript" async="async"></script><!--async：可选。规定异步执行脚本（仅适用于外部脚本）。-->
```

说明：

src：表示引入的外部JS文件的路径和文件名（只能用于引入JS文件）

async：异步加载JS代码（在加载DOM元素的同时可以运行JS代码）

## 标识符

所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。、

标识符定义规则：

1.第一个字符必须是一个字母、下划线（_）或是一个美元符号（$）。

2.其他字符可以是字母、下划线、美元符号或数字。

3.不能把关键字、保留字、true、false和null作为标识符。



关键字：

break、else、new、var、case、finally、return、void、catch、for、switch、while、continue、function、this、with、default、if、throw、delete、in、try、do、instanceof、typeof等

保留字：

abstract、enum、int、short、boolean、export、interface、static、byte、extends、long、super、char、final、native、synchronized、class、float、package、throws、const、goto、private、transient、debugger、implements、protected、volatile、double、import、public等

注意：在JS中任意地方是严格区分字母大小写的！！！！

## 注释

### 1）单行注释

//注释内容		一般用于对当前行的代码时行说明（在Webstrom中的快捷键是Ctrl+/）

### 2）多行注释

/*

注释内容

注释内容

……

*/						也叫块注释。一般对下面的代码进行整体说明，且说明内容可能较多（在Webstrom中的快捷键是Ctrl+shift+/）

说明：

1）注释语句在浏览器中不会被解析执行，仅起说明作用：

2）在项目开发中，要习惯去写注释，主要便于后期的项目维护。

## 常量

常量也叫直接量或字面量，在程序中直接给出具体的数据。

常量是不可以改变的。

如：100,true,'abc',null.undefined等

## 变量

变量就是在内存中开辟一段空间用于存放某个数据。

变量必须要有变量名，变量名必须遵循标识符的命名规范。



定义：

1）只定义变量

var x;

var a,b,c

2）定义变量且赋值

var x1= true;

var y1=100, y2=null;

说明：

1）定义变量时不需要给出数据的类型（松散式语言特点）。

2）变量可以重复定义，后面会覆盖前面变量。

3）不用var定义变量也可以，默认是为window对象添加了属性

```
name='张三';// 相当于window.name='张三'
```

4）定义的变量如果没有赋值，系统将自动赋默认值'undefined'。

5）一条语句可以以分号结束，也可以不加分号；如果是多条语句写在同一行上，必须用分号隔开。

6）在书写代码时，除了字符串中可以使用中文标点外，其他任何地方只能用英文标点符号。

## 数据类型

数据类型指的是在内存存储的方式

分为：

### 1）基本数据类型

#### number：数值型

用来表示一个数字，通常用于加减乘除

分为整型和浮点型（小数位可以浮动）。

100（10进制）

0123（8进制）

0xae12（16进制）



isNaN（）：用来判断是不是不是一个数。

#### string：字符型

用引号（单双引号都可以，他们没区别）引起来的一串字符（可以是数字、字母、标点符号、汉字等），通常做描述用

'abc'

"avc"

"a\'bc"如果输出引号必须在引号前加/符号才可以（单双一致）。

#### boolean：布尔（逻辑）型

表示真（true）或假（false）

#### null：空

表示一个空对象的地址指定指向的为空。

#### undefined：未定义

表示定义了一个变量。当如果没有给这个变量赋值，系统将自动赋值为undefined。

### 2）引用数据类型

#### object：对象型

用来声明或存储一个对象（对象、函数、正则、字符、数值等）

var a=new Number(10);

var obj={

​	sno:'007',

​	sname='张三'

}

## 运算符

### 1）算术运算符

+-*/ %(求余/模) ++（自增） --（自减）

### 2）字符串运算符

+

用于实现字符串连接

### 3）关系运算符

＞	＜ 	＞= 	＜= 	== 	===  	!=  	!==

返回的结果只能是true或false。

比较办法：

a.数值比较，是比较其大小。

b.字符比较，是比较ASCII码值大小；

A->65,a->97,回车->13,ESC->27

c.汉字比较，是比较其Unicode编码值大小

可以通过charCodeAt()获取编码值

d.==和!=只比较值，不比较类型；===和!==既比较值又比较类型

比较：部分符号<数字<大写字母<小写字母<汉字

### 4）逻辑运算符

！（非，取反）、&&（与，一个为false，全为false）和||（或，一个为true全为true）三种。返回的值一般是逻辑值true或false，也可能返回其他值。



### 5）位运算符

暂不讲

### 6）三目运算符

语法：

表达式1？表达式2：表达式3

如果表达式1成立，返回表达式2的结果；不成立，返回表达式3的结果。

Tips：

三目运算相当于if语句的双分支结构。

如果表达式2或表达式3较为复杂，建议用if语句或switch语句实现。

## 流程控制

js是一门既面向过程，也面向对象的解释型语言。

面向过程：按照代码书写的顺序依次执行（OOP）。

js也是一门结构性语言。

js的结构分为顺序结构、分支（条件/选择）结构和循环结构的三种。

顺序结构：按照代码的书写顺序依次执行，一般包含初始化、赋值、输入/输出等语句。

条件结构：用if或switch语句实现，其中代码是有条件选择执行的。

循环结构：某部分代码在指定的条件范围内反复执行，用for/for...in/forEach/while/do...while语句实现。

### 1）条件结构

#### a.单分支

语法：

if(条件)语句：

或

if(条件){

​	语句组；

}

如果条件成立，将执行语句或语句组；条件不成立，执行if的下一条语句。

#### b.双分支

if(条件)语句1：else语句2；

或

if(条件){

​	语句组1；

}else{

​	语句组2;

}

如果条件成立，将执行语句1或语句组1；条件不成立，将执行语句2或语句组2。

#### c.多分支

if(){

}else if(){

}else{
}

#### d.情况语句switch

语法：

switch（条件）{

case 表达式：语句1或语句组1;[break;]

case 表达式：语句2或语句组2;[break;]

case 表达式：语句3或语句组3;[break;]

...

case 表达式：语句n或语句组n;[break;]

default:语句或语句组;

}

用法与java和c语言相同

### 2）循环结构

### a.计数循环for

语法for([变量];[条件];[循环]){

循环体;

[continue;]

[break;]

}

### b.当型循环while

语法：

while（条件）{

[循环体；]

[continue;]

[break;]

}

### c.直到型循环do...while

do{

[循环体；]

[continue;]

[break;]

}while(条件)

### d.数组和对象遍历（后面讲）

for...in:用于遍历数组和对象；

forEach()：用于遍历数组；

## break和continue语句

break可以用在switch和循环语句中（forEach循环除外），表示跳出（结束）情况语句或循环。

continue语句只能用在循环语句中（forEach循环除外），表示结束本次循环，继续下次循环。

## 函数

函数就是将具有一定功能的一段JS代码的封装，可以在程序的多个地方被反复调用。

### 1）定义函数

格式一：

function 函数名（形参列表）{

函数体：

[return [<表达式>]；]

}

格式二：

var 变量名 = function（形参列表）{

函数体：

[return [<表达式>]；]

}

格式三：

(function([形参列表]){

函数体；

[return [<表达式>];]

})（[实参列表]）

上面的函数叫做立即执行函数表达式（IIFE），它会自动调用自身，不能在其他地方被调用，一般用于JS库或JS插件的封装或闭包处理。

### 2）函数调用

函数名（[实参列表]）；

Tips:

函数一般不会自动执行（IIFE（立即执行函数表达式）除外），必须通过调用才能执行

### 3）return

函数可以通过return返回结果，如果return没有返回结果，表示结束函数的调用。

### 4)arguments对象

返回实参列表的一个伪数组。

一般用在不确定传过来的实参的个数的情况下。

## 对象（object）

对象，其实就是一种类型，即引用类型。用于将数据和功能组织在一起。

对象由属性和方法组成，通常用键值对定义。

### 1）对象定义

#### a）new构建

new Object();

#### b）字面量定义

var obj={

​	key:value;//属性

​	fn:function(){//方法

​		……	

​	}

}

### 2)对象引用

a)对象名.属性名

​	对象名.方法名([实参列表])

b)对象名[属性名]

## 数组（Array）

数组将一组数据组合到一起，并存入到一个变量中，数组是有序排列的，占用一段连续的内存空间。

一个数组可以存储不同类型的数据。

### 1)定义数组

a.new

new Array([值列表])

b.字面量创建

var arr=[值列表]

### 2）获取数组元素值

数组名[下标]//下标可以是一个数值型常量，也可以是一个表达式或函数或变量

### 3）遍历数组

一维数组用一个循环实现；二维数组必须用双重循环实现（先行后列）。

a.for

b.for...in			//推荐写法

c.forEach()

### 4)数组的属性和方法

a.length属性

获取数组的长度。

b.方法

i)push()

向数组中添加数组到数组最后

ii)pop()

删除数组最后的一个元素

iii)unshift()

向数组头部添加数据。

iv)shift()

删除数组第一个元素。

v)concat()

将两个或多个数组组合成一个数组。

vi)reverse()

对数组进行倒序处理。

vii)join()

将数组转换为字符串。

viii)splice()

删除、修改或向数组中添加数据。

## function类型

function是一个用来构建函数的类（构造函数）

### 函数内部属性

在函数内不，有两个特殊的对象：arguments和this。

callee：

arguments是一个类数组对象，包含着传入函数中的所有参数，主要用途是保存函数参数。

但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。

也即是说可以通过arguments.callee调用函数自身，一般用于函数的递归调用。

函数自己调用自己叫函数的递归调用

this指针对象

在全剧终this指向的是window（在JS中没有global这个全局对象，而JS的全局对象是Window）；

在函数中this指向的是这个函数指向所操作的当前对象。

## 内置对象

### 1）global对象

在JS中没有global对象，Web浏览器将Global作为window对象的一部分加以实现。

方法：

a.encodeURIComponent():对unicode进行编码处理

b.decodeURIComponent():对unicode进行解码处理

c.eval():具有字符串解析器作用（慎用！！！！！因为它的性能较差，且比较危险）

### 2）Math对象

该对象主要提供了大量的数学运算的属性和方法

属性：

Math.E

Math.PI

方法：

Math.min():取最小值

Math.max():取最大值

Math.round():四舍五入函数

Math.ceil():向上取整（取大于或等于操作数的最小整数）

Math.floor():向下取整（取小于或等于操作数的最大整数）

Math.random():产生[0,1)之间的一个任意小数

Math.abs(num):返回num的绝对值

Math.exp(num):返回Math.E的num次幂

Math.log(num):返回num的自然对数

Math.pow(num,power): 返回num的power次幂

Math.sqrt(num) :返回num的平方根

Math.acos(x) :返回x的反余弦值

Math.asin(x) :返回x的反正弦值

Math.atan(x) :返回x的反正切值

Math.atan2(y,x) :返回y/x的反正切值

Math.sin(x): 返回x的余弦值

Math.cos(x): 返回x的正弦值

Math.tan(x) :返回x的正切值

## 面向对象

创建对象：

### 1）常规创建

a.new

b.字面量创建

### 2）工厂模式

通过封装函数实现创建一批相似的对象。

缺陷：无法知道创建的对象是哪一个对象的实例

### 3）构造函数

构造函数是用来构建一个类（ES5中没类的概念，实际上这里的构造函数就是类）

类是对象的一个抽象符号化表示（把相同或相似的一部分对象抽离出来就形成了一个类）。

对象是类的实例化（具体化）（赋予一定的属性和功能）



a.创建构造函数（类）

语法：

function 类名（[形参列表]）{

this.属性名 = 参数；

……

this.方法名 = function(){

函数体;

}

……

}

b.通过构造函数实例化对象

new 类名（[实参列表]）;

使用了构造函数的方法，和使用工厂模式的方法他们不同之处如下:

·构造函数方法没有显式的创建对象（new Object()）;

·直接将属性和方法赋值给this对象；

·没有return语句。

构造函数的方法有一些规范：

·函数名和实例化构造名相同且大写，（PS：非强制，但这么写有助于区分构造函数和普通函数）；

·通过构造函数创建对象，必须使用new运算符。

构造函数的执行过程：

·当使用了构造函数，并且new构造函数（），那么就后台执行了new Object（）；

·将构造函数的作用域给新对象，（即new Object（）创建出的对象），而函数体内的this就代表new Object()出来的对象。

·执行构造函数内的代码；

·返回新对象（后台直接返回）。

## 基本包装类型

在基本数据类型中有3个特殊的类存在：String、Number和Boolean。

上面三个基本类型都有自己的包装对象，有相应的属性和方法。调用方法的过程是在后台发生的，所以我们称作为基本包装类型

通俗的讲就是基本类型的数据都有一个包装它们的类，这些类都有自己的属性和方法，这些基本类型的数据都可以直接去调用这些属性和方法。



### 1）Boolean

没有自己的属性和方法。

### 2）Number

a.属性

MAX_VALUE 表示最大值

MIN_VALUE 表示最小值

NaN 非数值

NEGATIVE_INFINITY 负无穷大，溢出返回该值

POSITIVE_INFINITY 无穷大，溢出返回该值

prototype 原型，用于增加新属性和方法

b.方法

toString():将数值转化为字符串，并且可以转换进制

toLocaleString():根据本地数字格式转换为字符串

toFixed():将数字保留小数点后指定位数并转化为字符串

toExponential():将数字以指数形式表示，保留小数点后指定位数并转化为字符串

toPrecision():指数形式或点形式表述数，保留小数点后面指定位数并转化为字符串

valueof():显示原始值

3)String类型

a.属性

length

b.方法

str.charAt(n) 返回指定索引位置的字符

str.charCodeAt(n) 以Unicode编码形式返回指定索引位置的字符

str.concat(strl..str2) 将字符串参数串联到调用该方法的字符串

str.slice(n,m) 返回字符串n到m之间位置的字符串

str.substring(n,m) 返回字符串n到m之间位置的字符串

str.substr(n, m)返回字符串n开始的m个字符串

str.index0f(str, n)从n开始搜索的第- - 个str.并将搜索的索引值返回

str.lastIndexOf(str, n) 从n开始搜索的最后一个str.并将搜索的索引值返回

str.toLowerCase()将字符串全部转换为小写

str.toUpperCase()将字符串全部转换为大写

str.match(pattern) 返回pattern中的子串或null

str.replace (pattern, replacement) 用replacement替换pattern

str.search(pattern) 返回字符串中的pattern开始位置

str.split(pattern) 返回字符串按指定pattern拆分的数组

String.fromCharCode (ascii) 静态方法，输出Ascii码对应值

str.localeCompare(strl, str2) 比较两个字符串，并返回相应的值

## 变量、作用域及内存

### 1）变量

a.基本类型的变量

基本类型的变量的值存储在栈中。

b.引用类型的变量

引用类型的变量的值存储在堆中，在栈中存储的是引用类型的变量的地址（指针）。

如果要获取引用类型变量的值，需要先从栈中获取地址，再按址查找，从而获取到值。

### 2）作用域

在ES5作用域分为全局作用域和局部作用域两种。

在ES6作用域分为全局作用域、局部作用域和块级作用域三种。

全局作用域：

定义在函数外部的变量拥有全局作用域。

局部作用域：

定义在函数内部的变量拥有局部作用域。

# JSON

JSON(Javascript Object Nataion：JS对象表示法)是一种轻量级的数据交换格式。用独立的编程语言的文本格式来存储和表示数据。

## 优点：

易于阅读和编写，同时也易于浏览器解析和生成，并有效的提升网络传输速率。

## 与XML比较：

JSON书写或解析时是一个对象，更容易解析，而XML是用用户自定义标签来存储数据的，对于前端来说，不容易书写且解析起来较为困难。

## JSON文件内容：

它可以是一个对象，也可以是一个数组，也可以是对象和数组的结合。

## JSON写在那里

可以写在Javascript中，也可以形成一个独立的。json文本文件

a.在JS中书写JSON数据

如果是对象，键可以用单或双引号引起来，数值型数据和逻辑值一级null不能加引号：如果是对象，键可以用单或双引号引起来，也可以不加引号。

b.独立的JSON文件

i)文件的扩展名必须是.json

ii)数据不能赋给某个变量

iii)键必须用双引号引起来

iv)值如果是字符型数据，必须用双引号引起来，其他类型的数据不能用引号引

v)在json文件中不能添加任何注释。

## 数据值可以是以下三种

①简单值:可以在JSON中表示字符串、数值、布尔值和null。但JSON不支持JavaScript中的特殊undefined.

②对象（{}）

③数组:（[]）

## 在实际开发中的数据处理

在实际项目开发中，如果后台工程师，还没创建好后台数据接口时，前端工程师可以先做数据mock（模拟），写对应的HTML、CSS、JS代码，等后台数据可以调用是，再进行替换即可。

在项目中，数据最好分离出来，形成单独的JSON文件。

## 解析JSON数据

### a)JS中的JSON

如果是JSON数据，可以直接访问，如果是JSON格式的字符串需要用JSON.parse()方法进行转换。

```
 JSON.parse();//将JSON格式的字符转换为JSON
 JSON.stringify();//将JSON转换为JSON格式的字符串
```

### b)解析JSON文件

JSON文件必须用ajax（异步请求）技术去获取，

## ajax请求

```
//创建请求对象
var xhr=new XMLHttpRequest();
//建立请求连接
xhr.open('get','./student.json',true)//get：请求方式 true/false true表示异步操作,false表同步 url:表请求路径
//前端对请求的结果进行处理
xhr.onreadystatechange =function (){
    if (xhr.readyState == 4 && xhr.status == 200){  //如果请求成功
        console.log(JSON.parse(xhr.responseText))   //responseText:获取请求的结果
    }else{
        console.log("请求失败")
    }
};
//发送请求到后台
xhr.send();
```

注意：如果发送ajax请求，必须以http（服务器端）的方式启动文件，不能在本地直接打开

## DOM操作

DOM(Document Object Model:文档对象模型)：是HTML和XML文档的边城街口，定义了访问和操作HTML和XML文档的标准方法。

DOM以树形目录结构表达HTML和XML文档,每一个节点就是一个dom元素

document->html->head/body->...

### 1）DOM节点层次

父子节点和同胞节点

在节点树中，顶端节点被称为根（root）

每个节点都有父节点、除了根（他没有父节点）

一个节点可拥有任意数量的子节点

同胞节点是拥有相同父节点的节点，也叫兄弟节点

### 2）DOM节点分类

元素节点：标签

属性节点：标签的属性

文本节点：标签后的换行符

文档节点：document

### 3）DOM节点的名称(nodeName)

元素节点的 标签名相同

属性节点的 属性名相同

文本节点的 #text

文档节点的 #document

### 4）DOM节点的值（nodeValue）

元素节点的  undefined或null

属性节点的 文本本身

文本节点的 属性值

### 5）  DOM节点的类型（nodeType）

元素 1

属性 2

文本 3

注释 8

文档 9

## 节点操作

### a）获取节点

通过ID获取节点[返回具体某个节点]

​	document.getElementById（ID名）

通过标签名获取节点[返回节点数组， 即使只有一个]

​	document.getElementsByTagName(标签名)

通过标签的name值获取节点[返回 节点数组]

​	document.getElementsByName(Name名)

通过class值来获取节点[返回节 点数维]

​	document.getElementsByClassName（class名）

根据选择器返回找到结果集中的第-一个

​	document.querySelect("选择器' )

根据选择器返回找到的结果集，是个节点数组

​	document.querySelectAll("选择器”)

### b）创建DOM节点

```
//创建元素节点
var 元素节点名=document.createElement('标签名');

//创建文本节点
var 文本节点名=document.createTextNode('文本内容');

//创建属性节点
var 属性节点名=document.createAttribute('属性名'); //添加属性名
属性节点名.value = '属性值'; //为属性设置值

//关联以上三个节点
元素节点名.appendChild(文本节点名);  //在元素节点上添加文本节点
元素节点名.setAttributeNode(属性节点名);  //在元素节点上添加属性节点
document.body.appendChild(元素节点名);	//将创建的节点添加到文档中
```

``` 
//另外写法（简洁写法）：
var oDiv = document.createElement('div'); //创建元素节点
oDiv.setAttribute('class','wrapper box'); //为元素节点添加属性及属性值
oDiv.innerHTML = '创建dom元素的简洁写法';  //为元素节点设置文本内容
document.body.appendChild(oDiv);
```

## 插入节点

### i）插入内部的尾部

父节点.appendChild(创建的节点)

### ii)插入内部的某个前面

父节点.insertBefore(创建的节点，已知的子节点)

## 替换节点

父节点.replaceChild(新节点，老节点)

## 克隆节点

克隆节点就是将我们需要的节点复制一份，我们的克隆节点有深度克隆和浅克隆。

深度克隆:包含子节点一起克隆。

浅克隆:只会将找到的这个节点克隆， 子节点不会克隆



需要被赋值的节点，cloneNode（true/false）:

true:复制当前节点以及所有子节点。（深度克隆）

false：仅复制当前节点。（浅克隆）

## 删除节点

i)删除当前节点及子节点

节点.remove();

ii)删除子节点

父节点.removeChild(子节点);

## 节点属性操作

### i）获取属性值

DOM节点.属性名	//不能获取用户自定义属性

DOM节点.getAttribute(属性名)	//获取所有属性（包括用户自定义属性）的值

### ii）设置属性值

DOM节点.属性名 = 属性值	//不能设置用户自定义属性

DOM节点.setAttribute(属性名，属性值)	//设置所有属性（包括用户自定义属性）的值

### iii）删除属性值

DOM节点.属性名 = ''	//不能删除用户自定义属性

DOM节点.removeAttribute(属性名)	//删除所有属性（包括用户自定义属性）的值

## 节点文本操作

i)获取文本

节点. innerHTM //获取节点下的所有内容包含了标签

节点. innerText //获取节点下的文本内容，会过滤掉标签

节点.value //获取input输入框等表单控件的内容

节点. getAttribute(“value" ) //value 是表单输入框的属性，可以使用getAttribute获得value值

ii)设置文本

节点innerHTM=” 文本内容”//会翻译html标签

节点. innerText =”文本内容”//不会翻译html标签

节点.value =值

节点setAttribute("value",值) //因为value是属性，所以也可以中这个方法设置内容

iii)删除文本

节点. innerHTM=””

节点innerText =””

节点.value =””

节点removeAttribute("value")

## DOM节点样式操作

### a)操作样式class

i)获取class

节点.className 获取节点的所有class

节点. getAttribute("class") 获取节点的所有class

ii)设置class

节点.className = 值

节点.setAttribute("class",值)

iii)其它方法

节点.classList.add(value); //为元素添加指定的类

节点.classList.containa(value); //判断元素是否含有指定的类，如果存在返回true

节点.classList.remove(value); //删除指定的类

节点.classList.toggle(value); //有就删除。没有就添加指定类

### b)操作内联样式

i)获取内联样式

节点.style.样式属性名//获取某个具体的内联样式

节点. style. cssText //获取某个节点的所有内联样式，返回字符串

ii)设置内联样式

节点style.样式属性名=属性值// 设置某个具体的内联样式

节点.style. cssText =属性值或属性值列表//设置某个节点的所有内联样式

# 常用事件

onload onclick ondblclick onmouseover onmouseout onmousemove onmousedown  onblur onfocus onsumbit onreset  onchange

onkeydown onkeyup onkeypress 

onresize

……

# JQuery

JQ是JS库，是对JavaScript的一个封装，也即是说JQ提供了大量的API，在开发时，以最少的代码实现最多的功能。

于2006年开源，现在已经发展成为集JS、CSS、DOM、Ajax于一体的强大的框架体系。

宗旨：write less,do more!(写的少，做得多)

## 学习文档

中文文档：https://www.jquery123.com

API学习或查询：https://jquery.cuishifeng.cn/

## 功能

1）控制页面样式

2）访问和操作DOM

3）时间处理

4）提供了大量的插件

5）Ajax技术的封装

6）提供了大量的动画处理

……

## 使用JQ

1）本地引入

```
<script src="jQuery/JQuery.js"></script>
```

2）CDN引入

```
<script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.0/jquery.js"></script>
```

注意：JQ必须先引入，然后才能调用它的API。可以在head标签引入，也可以在最后引入，一般在最后引入

## 选择器

### 1）基本选择器

id:#id;

class:.class

element:element

*选择所有标签（项目开发时，不要用，因为他要匹配完所有标签，性能差）

，选择多个DOM

### 2）层次选择器

选择器1 选择器2:选择选择器1的所有后代元素（选择器2）

选择器1>选择器2：只选择选择器1的子元素

选择器1+选择器2：紧挨着选择器1的第一个相邻元素（兄弟元素）

选择器1~选择器2：选择选择器1的所有兄弟元素

### 3）过滤选择器

#### a.简单过滤选择器

:first或first()	第一个元素

:last或last()	最后一个元素

:not(selector)	除selector之外的元素

:even	偶数

:odd	奇数

:eq(index)	第n个元素

:gt(index)	大于第n个后的元素

:lt(index)	小于第n个后的元素

:header	选择h1-h6所有标题元素

#### b.内容过滤选择器	

:contains(text)	获取包含指定文本内容的元素

:empty	获取不包含子元素或文本内容的元素

:has(selector)	获取含有选择器所匹配的元素

:parent	获取含有子元素或文本内容的元素

#### c.可见性过滤选择器

:hidden 选择display:none 或隐藏文本域（hidden）的元素

:visiable 选择display:block的元素

#### d.属性过滤选择器

[attr]						  	 获取含有指定属性的元素

[attr=value]				   获取属性值为value的元素

[attr!=value]				  获取属性值不为value的元素

[attr^=value]			 	获取属性值以value开头的元素

[attr$=value]			 	获取属性值以value结尾的元素

[attr*=value]			 	获取属性值含有value的元素

[attr1] [attr2] [attr3]	获取含有指定多个属性的元素

### 4）表单选择器

:input

:button

:submit

:text

:password

## DOM操作

### 1）属性操作

#### a.获取属性值

attr(属性名)

#### b.设置属性

attr(属性名,属性值)

#### c.删除属性

removeAttr(属性名)

### 2） 文本内容操作

#### a.获取文本及表单主键内容

html()	可以操作标签

text()	只能操作文本，不操作标签

val()	只能用于表单主键

#### b.设置（修改）文本及表单主键内容

html(内容)

text(内容)

val(内容)

#### c.删除文本及表单主键内容

html(‘’)

text(‘’)

val(‘’)

### 3）元素样式操作

#### a.设置样式

css('属性名','属性值')	设置一个样式

css({'属性名1':'属性值1','属性名2':'属性值2',……})	设置多个样式

#### b.操作类

##### i)添加类

addClass(类名)		添加一个类名

或

addClass(‘类名1 类名2 ...’)		添加多个类名

##### ii)删除类

removeClass()			清空类名

或

removeClass('类名')			清空指定的类名

或：

removeClass('类名1 类名2 ....')			清空指定的多个类名



### 4）页面元素操作

#### a.创建DOM节点

$(dom节点内容)

#### b.在内部添加DOM节点

append()

appendTo()

prepend()

prependTo()

#### c.在外部添加DOM节点

before()

insertBefone()

after()

insertAfter()

#### d.复制DOM节点

clone()

clone(true)

#### e.删除DOM节点

remove()

remove(dom节点)

empty()

## 尺寸相关

### 1）获取和设置元素的尺寸

$(dom).width()/height()																			获取元素的宽高度

$(dom).innerWidth()/innerHeight()														 获取包括padding的宽/高度

$(dom).outerWidth()/outerHeight()														获取包括padding和border的宽/高度

$(dom).outerWidth(true)/outerHeight(true)										 获取包括padding、border和margin的宽/高度

### 2）获取相对页面的绝对位置

offset()

### 3）获取浏览器可视区的宽高

$(window).width()

$(window).height()

### 4）获取页面文档的宽高

$(document).width()

$(document).height()

### 5）获取页面滚动距离

$(document).scrollTop()

$(document).scrollLeft()

## 遍历DOM

$(dom).each(function(index,dom){	//index为下标，dom为遍历的每一个DOM元素

​	...

})

## 事件

click()鼠标单击

mouseover()鼠标进入(进入子元素也触发)

mouseout()鼠标离开(离开子元素也触发)

mouseenter()鼠标进入(进入子元素不触发)

mouseleave()鼠标离开(离开子元素不触发)

keydown()按下键盘键

keyup()松开键盘键

keypress()从键盘输入字符

blur()元素失去焦点

focus()元素获得焦点

submit()用户递交表单

hover()同时为mouseenter和mouseleave事件指定处理函数

ready() DOM加载完成

resize()浏览器窗口的大小发生改变

scrol1()滚动条的位置发生变化

## 动画

### 1）显示/隐藏/切换

show()	显示

hide()	隐藏

toggle()	切换

### 2）滑动

slideDown()	向下滑动

slideUp()	向上滑动

### 3）淡入/淡出

fadeIn()	淡入

fadeOut()	淡出

fadeTo()

### 4）动画

animate()

支持以下属性:

backgroundPosition

borderWidth

borderBot tomWidth

borderLeftWidth

borderRi. ghtWidth

borderTopWidth

borderSpacing

margin

marginBottom

marginLeft

marginRight

marginTop

outlineWidth

padding

paddingBot tom

paddingLeft

paddingRight

marginTop

outlineWidth

padding

paddingBot tom

paddingLeft

paddingRight

paddingTop

height

width

maxHeight

maxWidth

minHeight

maxWidth

font

fontSize

bottom

left

right

top

letterSpacing

wordSpacing

lineHeight

textIndent

# JSON

JSON(JavaScript Object Notation:JS对象简谱)是一种轻量级的数据交换格式

JSON是ECMA指定的应该数据表示规范，是ECMAScript的一个子集。采用独立于编程语言的文本格式来存储和表示数据。表示数据结构清晰、简洁、易于阅读和解析。

逐渐取代了XML数据格式。

它实际上就是一个对象或数组，或对象中含有数组，或数组中含有对象。

## JSON的表示方式

### 1）对象表示

```
var obj = {
  id:'937493',
  name:'Tom',
  sex:'male',
  age:18,
  addr:'ShenZhen China'
};
```

### 2）数组

```
var score = [78,89,90,100,56,88]
```

### 3）复杂表示法（对象+数组）

```
var students = [
  {
    id:'1842',
    name:'Tom',
    sex:'male',
    age:18,
    score:[78,89,90,100,56,88],
    addr:'广东深圳'
  },
  {
    id:'7766',
    name:'Amy',
    sex:'female',
    age:19,
    score:[78,45,33,99,66,77],
    addr:'广东广州'
  },
  {
    id:'9468',
    name:'bobo',
    sex:'male',
    age:17,
    score:[77,66,77,99,55,44],
    addr:'湖北武汉'
  }
];
```

## JSON文件

1）不需要将数据赋给一个变量

2）键和字符型值（除数值型、布尔型、null、undefined（一般没有）之外）必须用双引号引起来，不能用单引号或不用引号

3）不允许出现分号和多余的逗号

4）不能出现注释语句

5）文件的扩展名必须是JSON

如：

```
[
  {
    "id":"1842",
    "name":"Tom",
    "sex":"male",
    "age":18,
    "score":[78,89,90,100,56,88],
    "addr":"广东深圳"
  },
  {
    "id":"7766",
    "name":"Amy",
    "sex":"female",
    "age":19,
    "score":[78,45,33,99,66,77],
    "addr":"广东广州"
  },
  {
    "id":"9468",
    "name":"bobo",
    "sex":"male",
    "age":17,
    "score":[77,66,77,99,55,44],
    "addr":"湖北武汉"
  }
]
```

# Ajax

## 1）什么是Ajax？

Ajax(Asynchronous JavaScript And Xml):异步的JavaScript和XML），目的是让JavaScript发送http全球，与后台通信，获取数据和信息。

Ajax技术的原理是实例化xmlhttp对象，使用此对象与后台通信，在通信过程中不会影响后续的JS的执行，从而实现异步操作

## 2）同步和异步

同步就是做完一件事（任务）后再做另一件事，后一件事的执行依赖于前一件事件的完成。同步会影响到后面的JS代码的执行时间

异步是指同时可以做多件事情（任务）。不会影响到后面JS代码的执行时间。

## 3）局部刷新和无刷新

Ajax可以实现局部刷新，也叫无刷新，就是整个页面不刷新，只是局部刷新而已。Ajax可以自己发送请求，不用通过浏览器地址栏，所以页面不会刷新。

## 用Ajax发请求

### 写法1

$.ajax({

​	type:'get/post',																			//请求方式，默认为get

​	url:'请求的文件名或后台的地址',												//请求的地址

​	async:true/false,																		 //异步或同步

​	data:{																						    //上传到服务器端的数据

​			//数据

​	},

​	dataType:'json/jsonp/xml/text/javascript',							  //返回的数据类型或解决跨域（jsonp）

​	success:function(res){ 															    //成功回调的处理代码

​			//成功回调的处理代码

​	},

​	error::function(err){ 															      //失败回调的处理代码

​			//失败回调的处理代码

​	},

​	timeout:时间(毫秒),																    //请求超时时间

​	……

})

### 写法2

$.ajax({

​	type:'get/post',																			//请求方式，默认为get

​	url:'请求的文件名或后台的地址',												//请求的地址

​	async:true/false,																		 //异步或同步

​	data:{																						    //上传到服务器端的数据

​			//数据

​	},

​	dataType:'json/jsonp/xml/text/javascript',							  //返回的数据类型或解决跨域（jsonp）

​	timeout:时间(毫秒),																     //请求超时时间

​	……

}).done(function{ 																		    //成功回调的处理代码

​	...

}).fail(function(){ 															     	  	 //失败回调的处理代码

​	...

})

### 写法3(推荐写法)：

$.ajax({

​	type:'get/post',																			//请求方式，默认为get

​	url:'请求的文件名或后台的地址',												//请求的地址

​	async:true/false,																		 //异步或同步

​	data:{																						    //上传到服务器端的数据

​			//数据

​	},

​	dataType:'json/jsonp/xml/text/javascript',							  //返回的数据类型或解决跨域（jsonp）

​	timeout:时间(毫秒),																     //请求超时时间

​	……

}).then(function{ 																		    //成功回调的处理代码

​	...

}).catch(function(){ 															     	  	 //失败回调的处理代码

​	...

})

# JSONP

## 1）同源策略

同源策略 是由NetScape提出的一个著名的安全策略。

所谓的同源，指的是协议，域名，端口相同。浏览器处于安全方面的考虑，只允许本域名下的接口交互，不同源的客户端脚本，在没有明确授权的情况下，不能读写对方的资源。

http://127.0.0.1:8080	http为协议，127.0.0.1为域名，8080为端口

只要协议、域名和端口任意一个不相同，就会出现跨域情况。

## 2）在JQ中解决跨域

$.ajax({

​	...

​	dataType:'jsonp'

​	...

}).then(function(){

​	...

})

# Vue

1、JavaScript框架

2、简化DOM操作

3、响应式数据驱动

## 调用Vue

```
<!-- 开发环境版本，包含了有帮助的命令行警告 -->
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
```

或者：

```
<!-- 生产环境版本，优化了尺寸和速度 -->
<script src="https://cdn.jsdelivr.net/npm/vue"></script>
```

## 第一个程序vue

格式

html部分

```
<body>
  <div class="app">
    {{ message }}
  </div>
</body>
```

javascript及vue调用部分

```
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script>
  var app = new Vue({
    el:".app",
    data:{
      message:'Hello Vue!'
    }
  })
</script>
```

el:挂载点

## vue指令

指的是以v-开头的一组特殊语法

### v-text					

​							  //设置标签的文本值（textContent）

​							  //默认写法会替换全部内容，使用差值表达式{{}}可以替换指定内容

​							  //内部支持写表达式

### v-html				 

​							 //设置标签的innerHTML

​							 //内容中有html结构会被解析为标签

​							 //v-text指令无论内容是什么，只会解析为文本

​							//解析文本用v-text，解析html结构用v-html

```
<h2 v-text="content"></h2>        <!--只会显示文本和标签的组合，不加载标签-->
<h2 v-html="content"></h2>        <!--加载标签，不显示标签，只显示文本-->
```

### v-on					

​							//为元素绑定事件

​							//事件名不需要写on

​							//指令可以简写为@

​							//绑定的方法定义在methods属性中

​							//方法的内部通过this关键字可以访问定义在data中的数据

### v-show				

​							//根据真假（true或false）切换元素的显示状态

​							//原理是更改元素的display属性，实现显示影藏

​							//指令后面的内容最终都会解析为布尔值（true或false）

​							//如果为true元素显示，为false元素隐藏

​							//数据改变之后对应的显示状态会同步更新

### v-if

​							//根据表达值的真假（true或false）切换元素的显示状态和隐藏（操纵dom元素）

​							//本质是通过操纵dom元素来切换显示状态

​							//表达式的值为true,元素存在于dom树中，若为false，从dom树中移除

​							//频繁的切换使用v-show,反之使用v-if，前者切换消耗小

### v-bind

​							//v-bind指令的作用是：为元素绑定属性

​							//完整写法是v-bind:属性名

​							//简写的话可以直接省略v-bind，只保留：属性名

​							//需要动态的增删class建议使用对象的方式

### v-for

​							//根据数据生成列表结构

​							//数组经常和v-for结合使用

​							//语法是（item,index）in 数据

​							//item和index可以结合其他指令一起使用

​							//数组长度的更新会同步到页面上，是响应式的

### v-on补充

​							//传递自定义参数，事件修饰符

事件修饰符更多可以参考https://cn,vuejs.org/v2/api/#v-on

​							//事件绑定的方法写成函数调用的形式，可以传入自定义参数

​							//定义方法时需要定义形参来接收传入的实参

​							//事件后面跟上.修饰符可以对事件进行限制

​							//.enter可以限制触发的按键为回车

​							//事件修饰符有多种

### v-model

​							//获取和设置表单元素的值（双向数据绑定）

​							//v-model指令的作用是便捷的设置和获取表单元素的值

​							//绑定的数据会和表单元素值相关联

​							//绑定的数据<-->表单元素的值

### v-cloak

用法：

1、提供样式

[v-cloak]{

​	display:none;

}

2、在差值表达式所在的标签中添加v-cloak指令

背后的原理：先通过样式隐藏内容，然后在内存中进行值的替换，替换好后再显示最终的结果

## 网络应用

Vue结合数据开发的应用

## axios

功能强大的网络请求库

<script src="https://unpkg.com/axios/dist/axios.min.js">
</script>

axios必须先导入才可以使用

使用get或post方法即可发送对应的请求

then方法中的回调函数会在请求成功或失败时触发

通过回调函数的形参可以获取响应内容，或错误信息

### 文档传送门

https://github.com/axios/axios

## axios+Vue

结合Vue一起

axios回调函数中的this已经改变，无法访问到data中数据

把this保存起来，回调函数中直接使用保存的this即可

和本地应用的最大区别就是改变了数据来源

## NPM

包管理器

npm（全称：Node Package Manager）,node包管理器

是Node.js默认的、以JavaScript编写的软件包管理系统

npm来分享和使用代码已经成了前端的标配

官网：https://www.npmjs.com

npm被全球超过1100万开发人员所依赖

拥有超过一百万个软件包，是世界上最大的软件注册表

### 安装NPM工具

npm是Node.js默认的软件包管理系统

安装完毕node后，会默认安装好npm

npm本身也是基于Node.js开发的软件

下载Node：http://nodejs.cn

打开cmd

检测是否下载了node.js

指令是 node -v

检测是否下载npm

指令是 npm -v

全局使用npm

指令是 npm install npm -g

在当前目录下安装例如JQuery指令为：cd 到所需目录

输入npm install jquery

bootstrap和其它库同理

全局则是 npm install jquery -g

### 设置npm访问为淘宝镜像

打开cmd

第一种方法：

查看镜像网址

npm config get registry

更改镜像为淘宝网址

npm config set registry https://registry.npm.taobao.org --global

(其中 --global 是全局的意思)

第二种方法：

使用nrm工具切换淘宝源

npm nrm use taobao 

如果要切换为官方源

npm nrm use npm

### NPM的使用

npm -v 通过查看版本，看npm是否安装成功

npm install <Module Name> 使用 npm 命令安装模块

npm install <Module Name> -g 可以直接在命令行里使用

npm list -g 查看所有全局安装的模块

npm list vue 查看某个模块的版本号

npm -g install npm@5.9.1 (@后跟版本号)这样我们就可以更新npm版本

npm install -save moduleName      #-save 在package文件的的dependencies节点写入以来

npm install -save-dev moduleName       #-save-dev 在package文件的devDependencies节点写入以来 			dependencies:运行时的依赖，发布后，即生产环境下还需要用的模块

devDependencies:开发时的依赖。里面的模块是开发时用的，发布时用不到它，比如项目中使用的gulp,压缩css、js模块.这些模块在我们的项目部署后是不需要的

### Package.json属性说明

name 包名

version 包版本号

description 包的描述

homepage 包的官网url

author 包的作者姓名

contributors 包的其它贡献者姓名

dependencies 依赖包列表。如果依赖包没有安装，npm会自动将依赖包安装在 node_module 目录下

repository 包代码存放的地方类型。可以是git或svn，git可在Github上。

main main字段指定了程序的主入口文件，require('moduleName')就会加载这个文件。这个字段的默认值是模块根目录下面的index.js。

keywords 关键字

package.json文件中的版本号说明，安装的时候代表不同的含义

”5.0.3“	表示安装指定的5.0.3版本

"~5.0.3"	表示安装5.0.X中最新的版本

"^5.0.3"	表示安装5.X.X中最新的版本

### NPM常用指令

NPM提供了很多指令，例如install和publish，使用npm help可查看所有命令。

使用npm help <command> 可查看某条命令的详细帮助，例如npm help install。

在package json 所在目录下使用 npm install . -g 可先在本地安装当前命令行程序，可用于发布前的本地测试。

使用npm update <package> 可以把当前目录下 node_modules 子目录里边的对应模块更新至最新版本。

使用npm update <package> -g 可以把全局安装的对应命令行程序更新到最新版。

使用npm cache clear 可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。

使用npm unpublish <package> @<version> 可以撤销发布自己发布过的某个版本代码。

### 包的使用

通过命令行使用npm下载和更新包

没有webpack之前搜寻整个node_modules目录来定位每个包的路径再手动添加到我们的HTML文件中（实在太太不方便了）

大多数编程语言都会提供从一个文件导入另一个文件代码的机制。然而JavaScript最初设计时并没有这个特性，因为JavaScript原本是为了在浏览器端运行而设计的，并没有权限获取计算机客户端的文件系统（安全考虑）。所以很长一段时间以来，组织多个文件的JavaScript代码就是把每个文件下载下来，变量是全局共享的。

CommonJS中很大的一部分便是对模块系统的规范

使用require语句导入包

新的ES6可以使用import导入包

## Yarn

### Yarn是什么

Yarn是由Facebook、Google、Exponent和Tilde联合推出了一个新的JS包管理工具，正如官方文档中写的，Yarn是为了弥补npm的一些缺陷而出现的。因为NPM5以下会出现下面的问题：

-npm install的时候巨慢。特别是新项目拉下来要等半天。删除node_modules,重新install的时候依旧如此。

-同一个项目，多人开发时，由于安装的版本不一致出现bug

官网：www.yarnpkg.com

### Yarn的安装

下载node.js,使用npm安装

npm install - g yarn

查看版本：yarn --version

安装node.js,下载yarn的安装程序：

提供一个.msi文件，在运行时将引导您在Windows上安装Yarn

Yarn淘宝源安装，分别复制粘贴一下代码行到黑窗口运行即可

yarn config set registry https://registry.npm.taobao.org -g

yarn config set sass_binary_site http://cdn.npm.taobao.org/dist/node-sass -g

### Yarn的基本使用

yarn init 			//初始化项目 同npm init,执行输入信息后，会生成package.json文件

yarn install 		//安装package.json里所有包，并将包及它所有的依赖项保存进yarn.lock

yarn install --flat			//安装一个包的单一版本

yarn install --force 		//强制重新下载所有包

yarn install --production 		//只安装dependencies里的包

yarn install --no-lockfile 			//不读取或生成yarn.lock

yarn install --pure-lockfile 			//不生成yarn.lock

yarn add [package]		//在当前项目中添加一个依赖包，会自动更新到package.json和yarn.lock文件中

yarn add [package]@[version]			//安装指定版本，这里指的时主要版本，如果需要精确到小版本，使用-E参数

yarn add [package]@[tag]					//安装某个tag（比如beta,next或者latest）

yarn add --dev/-D				//加到devDependencies

yarn add -peer/-P				//加到peerDependencies

yarn add --optional/-O			//加到optionalDependencies

### yarn优点

速度快

安装版本统一

更简洁的输出

多注册来源处理

更好的语义化

## NPM迁移到Yarn

可以从npm迁移到yarn，也可以从yarn迁移到npm。

有了yarn的压力之后，npm做了一些类似的改进，在npm5.0之前，yarn的优势特别明显。但是在npm之后，通过以上一系列的对比，我们可以看到npm5在速度和使用上确实有了很大提升，值得尝试。

如果你已经在个人项目上使用yarn，并且没有遇到更多问题，目前完全可以继续使用。但如果有兼容npm的场景，以及还没有切到yarn的项目，那现在就可以试试npm5了。

## WebPack

打包工具

### 课程大纲

#### 初识webpack5

webpack是一个模块打包器（构建工具）。它的主要目标是将JavaScript文件打包在一起，打包后的文件用于在浏览器中使用，但它也能够胜任转换（transform）、打包（bundle）或包裹（package）任何资源（resource or asset）。

官网：https://webpack.js.org/

中文文档：https://webpack.docschina.org/

##### 了解webpack原理和概念

树结构：在入口文件中引入所有资源，形成所有依赖关系树状图

模块：模块就是模块可以是commonJS或者AMD模块，对于webpack来说，所有的资源（css,img……）

chunk:打包过程中被操作的模块文件叫做chuck，例如异步加载一个模块就是一个chunk

bundle：bundle是最后打包后的文件，最终文件可以和chunk长的一模一样，但是大部分情况下他是多个chunk的集合

为了优化最后生产出的bundle数量可能不等于chunk的数量，以为有可能多个chunk被组合到了一个Bundle中。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210121161923276.png" alt="image-20210121161923276" style="zoom: 200%;" />

#### webpack的安装和基本体验

1、创建项目目录： webpack-demo

2、进入目录初始化NPM操作：npm init -y		(-y=-yes i=install)

3、安装webpack及webpack-cli:npm install webpack webpack-cli --D	(-D = --save-dev)

4、创建src目录或根据需要创建下面的子目录 --->

5、在src下创建一些js文件，和一个主入口文件index.js	-->

![image-20210121162854975](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210121162854975.png)![image-20210121162921854](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210121162921854.png)

![image-20210121162936242](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210121162936242.png)

6、控制台运行命令：webpack --mode=development (开发环境，加注释)

控制台运行命令：webpack --mode=production（生产环境）

7、可以使用node运行打包后的资源，也可以使用HTML引入打包后的资源

(注意！！！package.json下的name字段不要重复为webpack，否则下载失败！！！！)

#### webpack的五个核心概念

##### webpack.config.js【默认文件名】，使用的话不用设置指令

module.exports={}中包含的参数：

  const {resolve} = require('path');



module.exports = {

/**

 \* 1、entry

 \* 入口（entry）指示webpack以哪个文件作为入口起点开始打包，分析构建内部依赖图

 */ 

  entry:'./src/index.js', //从index.js开始

/* 2、output

\* 输出（output）指示webpack打包后的资源bundles输出到哪里、以及如何命名

*/

  output:{        //输出格式

​    filename:'build.js',      //文件名为build.js

​    path:resolve(__dirname,'build'),    //在build文件夹中建立

  },

/* 3、loader

\* loader让webpack能够去处理那些||javascript资源css、img等，将它们处理成webpack能够识别的资源，可以理解成一个翻译过程（webpack本身只能理解js和json）

*/

  module:{      //模块

​    rules:{     //规则

​      

​    }

  },

/* 4、plugins

\* 插件（plugins）可用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等。

*/

  plugins:[

​    

  ],

/* 5、mode

\* 模式（mode）指示webpack使用相应模式的配置

\* 开发模式（development）：配置比较简单，能让代码本地调试运行的环境。

\* 生产模式（production）：代码需要不断优化达到性能最好。能让代码优化上线运行的环境。

\* 都会启用一些 插件，生产模式使用插件更多

*/

  mode:'production'   //生产模式 production - 开发模式 development

}

##### 多入口和多出口情况

###### 入口文件

1、String：单入口，打包成一个chunk，输出bundle文件，chunk的名称默认。

entry:'./src/index.js'

2、Array：多入口，写多个入口，所有入口文件形成一个chunk（名称默认），输出只有一个bundle，chunk名称默认

entry:["./src/two.js","./src/index.js"]

3、Object：多入口，有几个入口文件就生成几个chunk,并输出几个bundle文件，chunk的名称是key

entry:{

​	two:"./src/two.js"

​	index:"./src/index.js"

},

4、特殊用法：

entry{

//数组中所有入口文件生成一个chunk,输出一个bundle文件，chunk的名称是key

onetwo:["./src/one.js","./src/two.js"]

//形成一个chunk，输出一个bundle文件

index:'./src/index.js'

}

#### 打包样式资源

##### webpack打包CSS资源

需要使用npm下载安装两个loader帮我们完成打包

1.css-loader的作用时处理css中的@import和url这样的外部资源 

2.style-loader的作用是把样式插入到DOM中，方法是在head中插入一个style标签，并把样式写入到整个标签的innerHTML里

#npm i css-loader style-loader -D

#webpack

##### webpack打包less或sass资源

因为css只是单纯的属性描述，他并不具有变量、条件语句等，css的特性导致了它难组织和维护。

sass和less都属于css预处理器，定义了一种新的语言，其基本思想是用一种专门的编程语言。为CSS增加一些编程的特性，将CSS作为目标生成文件，然后开发者使用这只语言进行CSS编码工作。

less需要使用npm下载less包和less-loader

sass需要使用npm下载node-sass包和sass-loader

##### 把css作为单独文件打包

css内容是打包在js文件中的，可以使用"mini-css-extract-plugin"插件提取成单独的css文件。

1.在webpack.config.js中引入插件

const MiniCssExtractPlugin = require("mini-css-extract-plugin");

2.在plugins模块中使用插件

plugins:[new MiniCssExtractPlugin()];

或通过参数 filename重新命名提职的css文件名

new MiniCssExtractPlugin({filename:'./css/demo.css'})

3.在CSS的rules中，(less和sass同理)使用MiniCssExtractPlugin.loader取代style-loader,提取js中Css内容为单文件

rules:[

​      { test: /\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader','postcss-loader'] }, 

​      { test: /\.less$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader'] },

​      { test: /\.scss$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader'] }

​    ]

##### 处理css的兼容性

需要使postcss处理，下载两个包post-loader和postcss-preset-env

- ​	npm i postcss-loader postcss-preset-env -D

  postcss会找到package.json中browerslist里面的配置，通过配置加载css的兼容性

  修改loader的配置，新版需要写postcss.config.js,less和sass兼容性同理

##### 压缩CSS

使用optimize-css-assets-webpack-plugin插件压缩CSS内容

1.引入插件

const OptimizeCssAssetsWebpackPlugin=require('optimize-css-assets-webpack-plugin');

2.使用插件

plugins:[new  OptimizeCssAssetsWebpackPlugin()];

#### 打包HTML资源

使用插件（plugins）对HTML文件进行处理（html-webpack-plugin）

使用步骤：1.下载 2.引入 3.使用

下载安装：npm i html-webpack-plugin -D

webpack5版本以上可能会冲突，这时候只要确定加上版本号就好了，如下

详细见以下版本相关

引入插件：const HtmlWebpackPlugin = require("html-webpack-plugin")

使用插件：plugins:[

//功能：默认会创建一个空的HTML文件，自动引入打包输出的所有资源（JS/CSS）

//new HtmlWebpackPlugin()

//通过参数可以输出有结果的HTML资源

new HtmlWebpackPlugin({

//复制'./src/index.html'文件，并自动引入打包输出的所有资源(JS/CSS)

template:"./src/index.html"

//默认是index.html名称，通过filename设置输出文件名称

//filename:"demo.html"

})

],

html-webpack-plugin插件生成的内存中的页面已帮我们创建并正确引用了打包编译生成的资源（JS/CSS）

##### 压缩JS和html代码

js代码只需设置成生产模式（production）模式，会自动压缩

压缩HTML方法

//通过参数可以输出有结构的HTML资源

new HtmlWebpackPlugin({

//复制'./src/demo.html'文件，并自动引入打包输出的所有资源（JS/CSS）

template:"./src/demo.html",

filename:"demo.html",

//压缩html代码

minify:{

//移除空格

collapseWhitespace:true,

//移除注释
removeComments:true

}

})

##### webpack打包多个html开发案例

多个html的规律是需要有多个entry，每个html一个entry，同时需要新建多个HtmlWebpackPlugin

//多个entry

entry:{

vendor:['jquery','./src/js/common.js'],

index:"./src/js/index.js",

cart:"./src/js/cart.js"

}

//负责打包html文件，将js注入到html中，minify压缩html

new HtmlWebpackPlugin({

​	filename:"index.html",

​	template:"./src/index.html",

​	chunks:["index","vendor"],

​	minify:{

​		removeComment:true;

​		collapseWhitespace:true;

​	}

}),



new HtmlWebpackPlugin({

​	filename:"cart.html",

​	template:"./src/cart.html",

​	chunks:["cart","vendor"]

}),

#### 打包图片资源

需下载url-loader和file-loader两个包，依赖关系

在css中引入图片

在HTML中使用图片 需要下载html-loader

#### 打包其他资源

不需要优化和压缩处理，直接输出的资源，称为其他资源。

#### 对js语法配置语法检查eslint

eslint是一个开源的js代码检查工具，初衷是为了让程序员可以创建自己的检测规则。实际生产中，团队内往往会制订一套统一的标准，让整个团队的编码风格达到一致。

eslint其实与webpack没有任何关系，两者并不互相依赖，甚至一般情况下我们并不会在webpack中进行eslint的配置，可以单独使用。

语法检查使用eslint-loader,并基于eslint包，只用来检查js语法。

注意只检查自己写的js代码，第三方库是不用检查的，可以在npmjs.com中查看规则。

需要使用js来的规则库来检查代码"airbnb"，需要eslint-config-airbnb-base和eslint-plugin-import两个包

npm i eslint-loader eslint eslint-config-airbub-base eslint-plugin-import -D

#### devServer配置与应用

devServer给我们提供了开发过程中的服务器，是一个使用了express的http服务器，它的作用主要是为了监听资源文件的改变，该http服务器和client使用了websocket的通信协议，只要资源文件发送改变，webpack-dev-server就会实时的进行编译。

只会在内存中编译，不会有任何输出，下载webpack-dev-server包

webpack-dev-server并不能读取你的webpack.config.js的配置中的output

启动devServer指令为：npx webpack serve 本目录执行

webpack5无法刷新，解决：添加配置：target:'web'

#### 配置可用的基本开发环境

#### 开发环境优化

打包构建速度

优化代码调式

##### 版本相关

"devDependencies": {

  "css-loader": "^5.0.1",

  "eslint": "^7.15.0",

  "eslint-config-airbnb-base": "^14.2.1",

  "eslint-loader": "^4.0.2",

  "eslint-plugin-import": "^2.22.1",

  "extract-text-webpack-plugin": "^3.0.2",

  "file-loader": "^6.2.0",

  "html-loader": "^1.3.2",

  "html-webpack-plugin": "^4.5.0",

  "less": "^3.12.2",

  "less-loader": "^7.1.0",

  "mini-css-extract-plugin": "^1.3.2",

  "node-sass": "^5.0.0",

  "optimize-css-assets-webpack-plugin": "^5.0.4",

  "post-loader": "^2.0.0",

  "postcss-loader": "^4.1.0",

  "postcss-preset-env": "^6.7.0",

  "purgecss-webpack-plugin": "^3.0.0",

  "purify-css": "^1.2.5",

  "purifycss-webpack": "^0.7.0",

  "sass-loader": "^10.1.0",

  "style-loader": "^2.0.0",

  "url-loader": "^4.1.1",

  "webpack": "^4.44.2",

  "webpack-cli": "^4.2.0",

  "webpack-dev-server": "^3.11.0"

 },

此版本可以使用，webpack5以上版本容易不兼容

#### 生产环境优化

代码运行的性能

#### HMR(模块热替换)

模块热替换（Hot Module Replacement 即HMR）是webpack提供的最有用的功能之一，它允许在运行时更新各种模块，而无需进行完全刷新。

启用这个功能，只需要修改一下webpack.config.js的配置，使用webpack内置的HMR插件就可以了，在devServer中使用hot参数。

启用webpack内置的HMR插件后，module.hot接口会暴露在index.js中，接下来需要在index.js中配置告诉webpack接受HMR的模块。

1.样式HMR功能，在开发环境中使用style-loader

2.HTM的HMR功能，默认也没有HMR功能（不用做HMR功能），需要在entry入口中引入html文件。

3.js的HMR功能，默认没有HMR功能，智能处理非入口文件的js文件。

启用webpack内置的HMR插件后，module.hot接口就会暴露在index.js中，接下来需要在index.js中配置告诉webpack接受HMR的模块

if(module.hot){

​	modeule.hot.accept('./print.js',funtion(){	//告诉 webpack接受热替换模块

​		console.log('Accepting the updated printMe module!');

​		printMe();

​	})

}

服务器检测到了print.js的代码变化并且执行了 module.hot.accept 的回调函数

#### 去除项目里的死代码

##### 去除没有用到的js代码

Webpack通过tree-shaking去掉了实际上并没有使用的js代码来减少包的大小。

1.必须使用es6模块化， 2.开启production环境

##### 去除没有用到的CSS

比如我们经常使用的BootStrap(140KB)就可以减少到只有 35KB大小

webpack使用purgecss-webpack-plugin去除无用的css

const{resolve,join} = require('path')

const PurgecssPlugin = require('purgecss-webpack-plugin');

const glob = require('glob');

const PATHS = {src:join(__dirname,'src')}



new PurgecssPlugin({

​	paths:glob.sync('${PATHS.src}/**/*',{nodir:true})

}),

## ES6

### ECMAScript 6 语法和应用

#### 认识ES6

##### ECMAScript和JavaScript的关系

ECMA是“European Computer Manufacturers Association”的缩写，中文称欧洲计算机制造联合会。这个组织的目标是评估，开发和认可电信和计算机标准

ECMA是标准,JavaScript是实现

类似HTML5是标准，IE10、Chrome、FF都是实现

目的是让所有前端脚本都实现ECMA

目前只有JavaScript实现ECMA标准，ECMAScript≈JS

ECMAScript简称ECMA或ES（ES6）

目前版本

高级浏览器支持ES6

低级浏览器主要支持ES3.1

##### ES6标准出台流程

ECMAScript是跨多个平台的许多厂商（包括浏览器厂商在内的各方组成）实施的不断发展的标准。

ES6（ECMAScript 2015）花费六年时间敲定，是一个很大的发行版。新的年度发布流程被制定，以简化流程并更快的添加功能。ES11（ES2020）是目前的最新版本。推动JavaScript提案沿着一条严格的发展道路前进：

Stage 0:strawman——最初的想法提交。

Stage 1:proposal(提案)——由至少一名成员倡导的正式提案文件，该文件包括API事例。

Stage 2:draft(草案)——功能规范的初始版本，该版本包含功能规范的两个实验实现。

Stage 3:candidate(候选)——提案规范通过审查并从厂商那里收集反馈

Stage 4:finished(完成)——提案准备加入ECMAScript，但是到浏览器或者Nodejs中可能需要更长的时间

##### 接触ES6的意义

对语法的改进，功能的增加

使用Vue、React、小程序、Nodejs等都在用

ES6以上版本再等等

#### ES6兼容解决

兼容表：http://kangax.github.io/compat-table/es6/

IE10+、Chrome、FireFox、移动端、NodeJS现在都支持

兼容低版本浏览器

在线转换（这种编译会加大页面渲染的时间）

提前编译（强烈建议这种方式，不影响浏览器渲染时间）

（比较通用的工具方案有babel，jsx，traceur，es6-shim等。）

##### 实验步骤

使用NPM全局安装babel-cli包。（babel-V）

找一个目录，用npm来初始化一个项目，用来搭建我们的babel环境（npm init）或（npm init -y）

babel提供的一个编译工具babel-node,也可执行我们的js代码（babel-node index.js）

在项目目录下新建.babelrc文件（这是babel的配置文件）
	{

​		"presets":["es2015","stage-2"],			//设置转码规则

​		"plugins":["transform-runtime"]		//设置插件

​	}

这里我们需要转换成es2015，安装我们需要的库：
npm install babel-core babel-preset-es2015 babel-plugin-transform-runtime babel-preset-stage-2 -save-dev

我们再打开我们babel项目下的package.json文件，做如下修改

"scripts":{"bulid":"babel src -w -d lib"},

编译整个src目录并将其输出到lib目录，这里的src指的是需要转换的目录，lib指的是输出的内容的存放目录，-w其实是-watch的意思，就是监听文件，实时编译输出

新建src目录和lib目录，记得一定要建，不然会报错，然后我们启动我们的babel工程

命令行输入npm run bulid。

#### let和const

ES6新增let和const命令，用来声明变量，用法类似var

let声明的变量，只在let命令所在的代码块内有效

let命令不存在变量提升

let命令不允许在相同作用域内，重复声明同一个变量

const命令声明一个只读的常量。一旦声明，常量的值就不能改变

const命令声明的常量不得改变值。即一旦声明，就必须立即初始化

const命令声明的常量，只在声明所在块级作用域内有效

const命令声明的常量不提升，只能在声明的位置后使用

const命令声明的常量，与let一样不可重复声明

const命令声明的复合类型的数据（主要是对象和数组），变量指向的内存地址

#### 箭头函数 Arrow Function

ES6允许使用“箭头“（=>）定义

不需要参数或需要多个参数，就用圆括号代

代码块部分多于一条语句，就用大括号括起来，并且使用return返回

箭头函数返回对象时，必须在对象外面加上括号

箭头函数使得表达更加简洁

箭头函数能够简化回调函数

关于箭头函数中的this指向

普通函数的this：指向它的调用者，如果没有调用者则默认指向window。

箭头函数的this：指向箭头函数定义时所处的对象，而不是箭头函数使用时所在的对象，默认使用父级的this。

综上：箭头函数没有自己的this，它的this是继承而来，默认指向在定义它时所处的对象（宿主对象）。

#### 数组的新增高级方法

filter 过滤器

map 映射

reduce 汇总



some() 数组里有一个为真返回真

every() 数组里全为真才返回真

#### Set和Map数据结构

Map数据结构类似于对象，是键值对的集合，传统的键只能用字符串，各种类型的值（包括对象）都可以作键。

##### 属性和操作方法

size属性，返回Map结构的成员总数

set(key,value)方法，设置set方法设置键名key对应的值为value,然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该

get(key)方法，读取key对应的键值，如果找不到key，返回undefined

has(key)方法，返回一个布尔值，表示某个键是否在当前Map对象之中。

delete(key)方法，删除某个键，返回true。如果删除失败，返回false。

clear(key)方法，清除所有成员，没有返回值

##### Map遍历

keys()返回键名的遍历器

values()返回键值的遍历器

entries()返回所有成员的遍历器

forEach()遍历Map的所有成员

#### 字符串和新增方法的模板字符串

##### 字符串的新方法

startsWith 判断以什么字符串开头

endsWith 判断以什么字符串结尾

##### 模板字符串

模板字符串（template string）是增强版的字符串，用反引号(`)标识。

#### ES6解构赋值和扩展运算符

##### 解构赋值

左右两边结构必须一样

右边必须有值

声明和赋值不能分开

##### 扩展运算符

...三点运算符

展开数组

默认参数

#### 对象的新语法

##### ES6的Class（类）概念

constructor 是构造方法

this关键字代表实例对象

通过extends关键字实现继承

super关键字，表示父类的构造函数，用来新建父类的this对象

##### JSON对象的新应用

JSON.stringify() 串行化

JSON.parse() 反串行化

简写

(属性和值)名字一样可以简写

方法一样可以简写（:function省）

#### Module模块化编程

##### 模块化优点

减少命名冲突

避免引入时的层层依赖

可以提升执行效率

##### export命令：用于规定模块的对外接口

一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量

import命令：用于输入其他模块提供的功能

import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里的变量名，必须与被导入模块(profile.js)对外接口的名称相同。

## axios

### 为axios应用准备接口案例

#### 项目的两种编程方式-模板式编程和接口式编程

RestFul API规范（URL，HTTP，版本，状态码，返回值，请求条件等规范）

GET（SELECT）：从服务器取出资源（一项或多项）

POST（CREATE）：在服务器新建一个资源。

PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。

PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）

DELETE（DELETE）：从服务器删除资源

我们配置接口时，这只是一种规范，只是建议大家按照规范来使用而已。

### Postman安装和使用

Postman一款非常流行的API调试工具。

Postman最早是作用chrome浏览器插件存在的

Postman提供了独立的安装包，不再依赖于Chrome浏览器了。同时支持MAC、Windows和Linux，推荐你使用这种方式安装。

https://www.getpostman.com/apps

### ES6中Promise的原理和应用

#### 主要用于异步计算

可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果

可以在对象之间传递和操作promise，帮助我们处理队列

#### 异步回调的问题：

之前处理异步是通过纯粹的回调函数的形式进行处理

很容易进入到回调地狱中，剥夺了函数return的能力

问题可以解决，但是难以读懂，维护困难

稍有不慎就会踏入回调地狱-嵌套层次深，不好维护

#### promise

promise是一个对象，对象和函数的区别就是对象可以保存状态，函数不可以（闭包除外）

并未剥夺函数return的能力，因此无需层层传递callback，进行回调获取数据

代码风格，容易理解，便于维护

多个异步等待合并便于解决

### axios的入门应用

以CDN的静态资源方式引入

发送GET请求（默认的方法）

axios("./user/12345");

发送POST请求

### axios的post和get请求方式

import axios from 'axios'

axios.request(config)

axios.get(url[,config])

axios.delete(url[,config])

axios.head(url[,config])

axios.post(url[,data[,config]])

axios.put(url[,data[,config]])

axios.patch(url[,data[,config]])



header("Access-Control-Allow-Origin:*"); 

axios.get('/user?ID=12345')

axios.get('/user',{

​	params：{

​		ID:12345

​	}

})

axios.post(url[,data[,config]])

axios.post('/user',{

​	firstName:'Fred',

​	lastName:'Flintstone'

})

### axios处理的并发请求

ajax请求过多对页面性能可能会有影响，以及代码不美观，代码过于臃肿，所以我们可以使用axios的并发请求axios.all()

axios.all()和promise.all()方法是一个道理

axios.all()这个方法在axios的构造函数是没有的，没在实例对象上。

### axios的全局配置方案

做完全局配置之后在发送axios请求时就简单了

axios.default.baseURL = "http://127.0.0.1";

axios.default.timeout = 5000;

axios.default.header.post["content-type"]="application/x-www-form-urlencoded";

//整理数据

axios.defaults.transformRequest = function(data){

​	data = JSON.stringify(data);

​	return data;

}

### axios的实例封装

有时候后台接口地址有多个并且超时时长不一样，我们不可能在axios中把每个后台请求的域名地址都拼接在URL中，并且在axios中的config写不同的超时时长，很繁琐，这个时候可以用到axios实例，在实例中可以配置这两种参数。

假如新建了一个axios实例但是没有参数，取得就是全局的配置值，实例中如果有则优先取实例中的。

#### axios实例的相关配置（config参数）

baseURL:请求的域名基本地址（如：http://localhost:8080）

timeout:后端定义的超时时长（默认是1000ms）

url:请求的路径（如：/data.json）

method:请求方法（get、post……）

headers:设置请求头

params:请求的参数拼接在url中

data:请求的参数放在request body中

//create 创建一个新的实例对象

var instance = axios.create({

​	url:“http://jsonplaceholder.typicode.com/users",

​	timeout:3000;

​	method:"post"

});

//即可调用方法，和axios实例同

instance.get("http://jsonplaceholder.typicode.com/users").then(Response=>{

console.log(Response);

})

### axios的拦截器应用

为每个请求都带上的参数，比如token，时间戳等。

对返回的状态进行判断，不如token是否过期

//请求拦截器

axios.interceptors.request.use(

config=>{

//每次发送请求之前判断是否存在token

//如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录请款

//即便本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断

const token = window.localStorage.getItem("token");

token&&(config.headers.Authorization = token);

return config;

},

error =>{

return Promise.error(error);

}

);

axios.interceptors.response.use(

response =>{

//如果返回的状态码为200，说明接口请求成功，可以正常拿到数据

//否则的话跑出错误

if(response.status === 200){

​	return Promise.resolve(response);

​	}else{

​	return Promise.reject(response);

​	}

},

//服务器状态码不是2开头的情况

//这里可以跟你们的后台开发人员协商好统一的错误状态码

//然后根据返回的状态码进行一些操作，例如登陆过期提示，错误提示等等

//下面列举几个常见的操作，其他需求可自行扩展

error => {

if(error.respone.status){

return Promise.reject(error.response);

}

}

)

# 2021新版Vue3全家桶

## vue官网

https://cn.vuejs.org/

## 认识VUE3

Vue（读音/vju:/,类似于 view）是一套用于构建用户界面的渐进式框架

目前的最新版本为：Vue3.0.4

Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。

和库是不一是Vue一套架构，会基于自身特点向用户提供一套相当完整的解决方案，而且控制权在框架本身；对项目的侵入性较大，使用者要按照框架所规定的某种特定规范进行开发，项目如果需要更换框架，则需要重新架构整个项目。

![image-20210309150131218](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210309150131218.png)

渐进式就跟这个图片一样，开发可以根据需求，逐渐递增所要的方式，但每个方式有不是依靠行特别强

### Vue的两核心

响应式的数据绑定：当数据发生改变，视图可以自动更新，可以不用关心dom操作，而专心数据操作

可组合的视图组件：把视图按照功能切分成若干基本单元，组件可以一级一级组合整个应用形成倒置组件树，可维护，可重用，可测试

## VUE开发初体验

通过静态CDN资源安装Vue最新版本

一、数据绑定，数据响应式

二、属性动态绑定的提示信息

三、样式的动态绑定

四、基本的事件操作

五、循环遍历输出数组中的值

## VUE CLI脚手架

Vue-CLi(Command Line Interface)

Vue-CLI是Vue官方提供的脚手架工具

默认已经帮我们搭建好了一套利用Webpack管理vue的项目结构

命令安装：npm install -g @vue/cli

检查版本：vue --version

创建项目：vue create 项目名称

配置文件详细

应用代码演示

### vue.config.js配置

配置文档：http://cli.vuejs.org/config/#vue-config-js

## App.vue属性说明

<template></template>写html

<script></script>写js

<style scoped></style>写css

## options基础定义和MVVM模式

Vue实例主要是封装了视图操作，包括有

- 数据读写
- 事件绑定
- DOM更新

options是vue实例参数，意思是构造选项

option的五类属性

数据：data、props、propsData、computed、methods、watch

DOM：el、template、render、renderError

生命周期钩子：beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、activated、deactivated、beforeDestroy、destroyed、errorCaptured

资源：directives、filters、components

组合：parent、mixins、extends、provide、inject

其它：先不看

![image-20210312160702345](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210312160702345.png)

## VUE基础语法

插值操作

绑定属性

计算属性

事件监听

条件判断

循环遍历

其它语法

### vue模板语法：插值、指令

插值：{{}}

指令：v-

（在{{}}和v-指令进行数据绑定时，支持js单个表达式

<p v-once>{{msg}}</p>数据只第一次时显示，不响应式

<p v-pre>{{msg}}</p>,内容原封不动的展示

<p v-text="msg"></p>，就相当于插值表达式的功能

<p v-html="title"></p>,可以解析标签

data:{

msg:'test message',

title:"<h1 style=‘color:red'>Title</h1>"

}

### vue模板语法：v-bind绑定属性

插值{{}}只能用在模板内容中，用于动态内容绑定

如果希望元素的属性也可以动态绑定，需要通过v-bind指令

“v-bind” 缩写 ":" （语法糖）

绑定有意义元素中的属性

绑定class属性，四种用法（字符串，数组，对象，方法）

绑定style属性

### vue模板语法：计算属性

计算属性关键词：computed。

计算属性在处理一些复杂逻辑时是很有用的。

computed:{

​	site:{

​		//getter

​		get:function(){

​			return this.name+''+this.url

​		},

​		//setter

​		set:function (newValue){

​			var names = newValue.split(' ')

​			this.name = names[0]

​			this.url = names[name.length - 1]

​		}

​	}

}

### Vue模板语法：事件监听

在前端开发中，需要经常和用户交互

判断事件监听器指令：v-on

缩写：@（语法糖）

参数：$event

v-on事件修饰符号

- .stop 阻止事件冒泡
- .self 当事件在该元素本身触发时才触发条件
- .capture 添加事件侦听器时，使用事件捕获模式
- .prevent 阻止默认事件
- .once 事件只触发一次

### Vue模板语法：条件分支指令

v-if和v-show

- v-if是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建
- v-show就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于CSS进行切换

v-if v-else

v-if v-else-if v-else

### Vue模板语法：循环遍历指令

遍历指令：v-for

遍历数组 v-for=“(item,[index]) in 数组”

遍历对象 v-for="(value,[key],[index]) in 对象"

vue中列表循环需加：key=“唯一标识”唯一标识可以是item里面id index等，因为vue组件高度复用增加key可以表示组件的唯一性，为了更好区别各个组件key的作用主要是为了搞笑的更新虚拟DOM，使用diff算法的处理方法，对操作前后的dom树同一层的节点进行对比，一层一层对比

![image-20210323140536147](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210323140536147.png)



## 网络封装



## 组件化开发



## VUE路由应用



## Vuex详解



## Vue3的新特性



## 项目实战



## Nuxt.js框架应用



## 基于Nuxt的SSR项目实战



# 前端静态资源库网站

http://cdn.baomitu.com

https://www.bootcdn.cn/

# JS补充知识点

## toString,tolocaleDateString等用法

https://blog.csdn.net/qq_36850813/article/details/80923651